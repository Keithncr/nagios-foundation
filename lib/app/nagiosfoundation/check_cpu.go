// +build windows linux darwin

package nagiosfoundation

import (
	"errors"
	"flag"
	"fmt"
	"os"

	"github.com/jkerry/nagiosfoundation/lib/pkg/cpu"
	"github.com/jkerry/nagiosfoundation/lib/pkg/nagiosformatters"
)

// CheckCPUWithHandler gets the CPU load then emits a critical response
// if it's above flag -critical, a warning if it's above
// flag -warning and good response for everything else.
//
// Returns are a response message and response code.
func CheckCPUWithHandler(cpuHandler func() (float64, error)) (string, int) {
	const checkName = "CheckAVGCPULoad"
	var warning = flag.Float64("warning", 85, "the average cpu threshold to issue a warning alert")
	var critical = flag.Float64("critical", 95, "the average cpu threshold to issue a critical alert")
	var metricName = flag.String("metric_name", "pct_processor_time", "the name of the metric generated by this check")
	flag.Parse()

	var msg string
	var retcode int
	var value float64
	var err error

	if cpuHandler == nil {
		err = errors.New("No GetCPULoad() service")
	} else {
		value, err = cpuHandler()
	}

	if err == nil {
		msg, retcode = nagiosformatters.GreaterFormatNagiosCheck(checkName, value, *warning, *critical, *metricName)
	} else {
		msg = fmt.Sprintf("%s CRITICAL - %s", checkName, err)
		retcode = 2
	}

	return msg, retcode
}

// CheckCPU executes CheckCPUWithHandler(), passing it the OS
// constrained GetCPULoad() function, prints the returned message
// and exits with the returned exit code.
func CheckCPU() {
	msg, retval := CheckCPUWithHandler(cpu.GetCPULoad)

	fmt.Println(msg)
	os.Exit(retval)
}
